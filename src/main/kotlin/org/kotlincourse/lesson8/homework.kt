package org.sergei.org.kotlincourse.lesson8

import org.sergei.org.kotlincourse.lesson4.strings

//Создайте функцию, которая будет анализировать входящие фразы и применять к ним различные преобразования, делая текст более ироничным или забавным.
// Функция должна уметь распознавать ключевые слова или условия и соответственно изменять фразу.



//fun main() {
//    var text1 = "Это невозможно выполнить за один день"

//    // Проверяем, содержит ли фраза слово "невозможно"
//    (if (text1.contains("невозможно", ignoreCase = true)) {
//        // Заменяем "невозможно" на нужную фразу
//        text1.replace("невозможно", "совершенно точно возможно, просто требует времени", ignoreCase = true)
//    } else {
//        text1 // Если "невозможно" не найдено, возвращаем исходный текст
//    }).also { text1 = it }
//
//    println(text1) // Выводим результат

    //Если фраза начинается с "Я не уверен":
    //Преобразование: Добавьте в конец фразы ", но моя интуиция говорит об обратном".

//    var text2 = "Я не уверен в успехе этого проекта"
//
//    // Проверяем, начинается ли строка с "Я не уверен"
//    if (text2.startsWith("Я не уверен", ignoreCase = true)) {
//        // Добавляем в конец строки ", но моя интуиция говорит об обратном"
//        text2 += ", но моя интуиция говорит об обратном"
//    }
//    println(text2)

    //Если фраза содержит слово "катастрофа":
    //Преобразование: Замените "катастрофа" на "интересное событие".

//    var  text3 = "Произошла катастрофа на сервере"
//
//    if(text3.contains("катастрофа", true)) {
//        // Заменяем её на фразу "интересное событие".
//       text3 = text3.replace("катастрофа", "интересное событие",true )
//    }
//    println(text3)

    //Если фраза заканчивается на "без проблем":
    //Преобразование: Замените "без проблем" на "с парой интересных вызовов на пути".


//    var text4 = "Этот код работает без проблем"
//
//    if(text4.contains("без проблем",true)) {
//        // Заменяем на фразу "с парой интересных вызовов на пути"
//        text4 = text4.replace("без проблем", "с парой интересных вызовов на пути",true)
//    }
//    println(text4)
//

    //Если фраза содержит только одно слово:
    //Преобразование: Добавьте перед словом "Иногда," и после слова ", но не всегда".

//    var text5 = "Удача"
//
//    // Проверяем, содержит ли строка только одно слово
//    if (text5.split(" ").size == 1) {
//        // Добавляем перед словом "Иногда," и после слова ", но не всегда"
//        text5 = "Иногда, $text5, но не всегда"
//    }
//
//    println(text5) // Выводим результат


// Задание 1: Извлечение Даты из Строки Лога. Используй indexOf или split для получения правой части сообщения.
// Описание: У вас есть строка лога вида "Пользователь вошел в систему -> 2021-12-01 09:48:23".
// Извлеките отдельно дату и время из этой строки и сразу распечатай их по очереди.
//
//    var textString = "Пользователь вошел в систему -> 2021-12-01 09:48:23"
//
//    // Находим индекс, где начинается дата и время (после символа '->')

//    val indexOfArrow = textString.indexOf("->")
//
//    // Извлекаем дату и время (всё, что после символа '->')

//    val dateTime = textString.substring(indexOfArrow + 3).trim()
//
//    // Выводим отдельно дату и время

//    val parts = dateTime.split(" ")
//    val date = parts[0]
//    val time = parts[1]
//
//    println("Дата: $date")
//    println("Время: $time")


// Задание 2: Маскирование Личных Данных
// Описание: Дана строка с номером кредитной карты "4539 1488 0343 6467".
// Замаскируйте все цифры, кроме последних четырех, символами "*".

//    var number = "4539 1488 0343 6467"
//
//    // Оставляем последние 4 цифры
//    val lastFourDigits = number.takeLast(4)
//
//    // Заменяем все остальные цифры на звездочки, включая пробелы
//    val maskedNumber = number.dropLast(4).replace(Regex("\\d"), "*")
//
//    // Выводим замаскированный номер карты
//    println("$maskedNumber$lastFourDigits")


    // Задание 3: Форматирование Адреса Электронной Почты. Используй replace
    // Описание: У вас есть электронный адрес "username@example.com".
    // Преобразуйте его в строку "username [at] example [dot] com".

//    var email = "username@example.com"
//
//    // Заменяем "@" на "[at]" и "." на "[dot]"
//    email = email.replace("@", " [at] ", true)
//    email = email.replace(".", " [dot] ", true)
//
//    // Выводим результат
//    println(email)
//

    // Задание 4: Извлечение Имени Файла из Пути
    // Описание: Дан путь к файлу "C:/Пользователи/Документы/report.txt".
    // Извлеките название файла с расширением.


//    var path = "C:/Пользователи/Документы/report.txt"
//
//        // Извлекаем название файла с расширением
//    val fileName = path.substringAfterLast("/")
//
//        // Выводим результат
//    println(fileName)

    // Задание 5: Создание Аббревиатуры из Фразы. Используй split с набором символов для разделения.
    // Используй for для перебора слов. Используй var переменную для накопления первых букв.
    // Описание: У вас есть фраза, например "Объектно-ориентированное программирование".
    // Создайте аббревиатуру из начальных букв слов (например, "ООП").

//    var phrase = "Объектно-ориентированное программирование"
//
//    // Разделяем фразу на слова по пробелам и дефисам
//    val words = phrase.split(" ", "-")
//
//    // Переменная для накопления первых букв
//    var abbreviation = ""
//
//    // Перебираем слова и добавляем первые буквы каждого слова в аббревиатуру
//    for (word in words) {
//        if (word.isNotEmpty()) {
//            abbreviation += word[0].uppercase() // Добавляем первую букву в верхнем регистре
//        }
//
//
//    // Выводим результат
//    println(abbreviation)

    //  Дополнительные задания

    // Написать метод, который преобразует строку из нескольких слов в строку, где каждое слово начинается с заглавной буквы а все остальные - строчные.
    // (можно использовать такой же подход как в задании 5, но накапливать не первые буквы а целиком слова, составленные из первой буквы с uppercase и оставшейся части слова)
    // Написать шифратор/дешифратор для строки.
    // Шифровка производится путём замены двух соседних букв между собой: Kotlin шифруется в oKltni.
    // Дешифровка выполняется аналогично.
    // Если длина строки - нечётная, в конец добавляется символ пробела до начала шифрования.
    // Таким образом все шифрованные сообщения будут с чётной длинной. Должно получиться два публичных метода: encrypt() и decrypt() которые принимают и возвращают строку.

fun main(){
//    val inputString = "объектно-ориентированное программирование"
//    println("Преобразованная строка: ${capitalizeWords(inputString)}")
//
//    val originalText = "Kotlin"
//    val encryptedText = encrypt(originalText)
//    println("Шифрованный текст: $encryptedText")
//    println("Дешифрованный текст: ${decrypt(encryptedText)}")
}
//
//// Метод для преобразования строки
//fun capitalizeWords(input: String): String {
//    return input.split(" ", "-")
//        .joinToString(" ") { word ->
//            if (word.isNotEmpty()) {
//                word[0].uppercase() + word.substring(1).lowercase()
//            } else {
//                ""
//            }
//        }


// Метод для шифрования строки
//fun encrypt(text: String): String {
//    // Если длина нечётная, добавляем пробел
//    val adjustedText = if (text.length % 2 != 0) text + " " else text
//    val encrypted = StringBuilder()
//
//    // Перебираем строку и меняем местами пары символов
//    for (i in adjustedText.indices step 2) {
//        if (i + 1 < adjustedText.length) {
//            encrypted.append(adjustedText[i + 1]) // Добавляем вторую букву
//            encrypted.append(adjustedText[i])     // Добавляем первую букву
//        }
//    }
//
//    return encrypted.toString()
//}
//
//// Метод для дешифрования строки
//fun decrypt(text: String): String {
//    val decrypted = StringBuilder()
//
//    // Перебираем строку и меняем местами пары символов
//    for (i in text.indices step 2) {
//        if (i + 1 < text.length) {
//            decrypted.append(text[i + 1]) // Добавляем вторую букву
//            decrypted.append(text[i])     // Добавляем первую букву
//        }
//    }
//
//    return decrypted.toString().trim() // Убираем пробел в конце, если был добавлен

    // Вывести таблицу умножения в консоль так, чтобы были ровные строки и столбцы.
    // В заголовках столбцов и строк - числа для перемножения. В перекрестии - результат умножения.
    // Каждый столбец должен быть выровнен по правому краю.



//        // Вывод заголовка таблицы
//    print("   ")  // Пустое место для угла
//    for (i in 1..9) {
//        print(String.format("%2d ", i))  // Заголовки столбцов
//    }
//    println()
//
//    // Вывод строк таблицы
//    for (i in 1..9) {
//        print(String.format("%2d ", i))  // Заголовки строк
//        for (j in 1..9) {
//            print(String.format("%2d ", i * j))  // Результаты умножения
//        }
//        println()       // Переход на новую строку после завершения внутреннего цикла
//    }
////

fun multiplyTable(first: Int, second: Int) {
    val formatLength = (first * second).toString().length + 1
    print(" ".repeat(formatLength))

    val xRange = getRange(first)
    val yRange = getRange(second)
    val formatter = "%${formatLength}s"
    for (i in xRange) {
        print(formatter.format("$i"))
    }
    println()
    for (i in yRange) {
        print(formatter.format("$i"))
        for (j in xRange) {
            print(formatter.format("${i * j}"))
        }
        println()
    }
}

private fun getRange(size: Int): IntProgression {
    return when {
        size > 0 -> 1..size
        size < 0 -> -1 downTo size
        else -> throw IllegalArgumentException("Неверное значение size")
    }
}

